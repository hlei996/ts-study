# 在node中搭建TS开发环境

# 安装TypeScript

默认情况下， TS会做出下面几种假设: 

1. 假设当前的执行环境是dom
2. 如果代码中没有使用模块化语句(import , export) ,便认为改代码是全局
3. 编译的目标代码是ES3

有两种方式更改以上的假设:

1. 使用tsc命令行的时候， 加上选项参数
2. 使用ts配置文件，更改编译选项

# TS的配置文件

使用了配置文件后， 使用tsc进行编译时，不能跟上文件名，如果跟上文件名，会忽略配置文件。

@types/node

@types是一个ts官方的类型库， 其中包含了很多对js代码的类型描叙

> JQuery: 用js写的, 没有类型检查
> 安装@types/jquery，为jquery库添加类型定义

# 使用第三方库简化流程
ts-node: 将ts代码在内存中完成编译， 同时完成运行

nodemon: 用于检测文件的变化

# 基本类型约束

> TS是一个可选的静态的类型系统

# 如何进行类型约束

仅需要在 变量， 函数的参数， 函数的返回值位置加上```:类型```

ts在很多场景中能进行类型推导

any: 任意类型,对该类型， ts不进行类型检查

> 小技巧: 如何区分数字字符和数字， 关键看怎么读？
> 如果按照数字的方式朗读，则为数字; 否则， 为字符串。

# 源代码和编译结果的差异

编译结果中没有类型约束信息

# 基本类型

- number: 数字
- string: 字符串
- boolean: 布尔
- 数组
- object: 对象
- null 和 undefined

null 和 undefined是所有其他类型的子类型， 它们可以赋值给其他类型

通过添加```strictNullChecks:true```, 可以获得更加严格的空类型检查，
null和undefined只能赋值给自身

# 其他常用类型

- 联合类型: 多种类型人选其一

配合类型保护进行判断

类型保护: 当对某个变量进行类型判断之后，在判断的语句中便可以确定它的确切类型，typeof可以出发类型保护

- void类型：通常用于约束函数的返回值，表示没有任何返回值

- nerver类型: 通常用于函数的返回值， 表示函数永远不会结束

- 字面量类型: 使用一个值进行约束

- 元祖类型 (Tuple): 一个固定长度的数组， 并且数中每一项的长度固定

- any类型: any类型可以绕过类型检查， 因此any可以赋值给任意类型

# 类型别名

对已知的一些类型定义名称

type 类型名 = ...

# 函数的相关约束
函数重载： 在函数实现之前，对函数调用的多种情况进行声明

可选参数: 可以在某些参数名后加上问号，表示该参数可以不用传递。可选参数必须在参数列表的末尾。
